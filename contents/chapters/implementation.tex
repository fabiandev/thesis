
\chapter{Implementation}
\label{cha:implementation}

After elaborating situations where runtime errors may occur in the previous chapter (see sec.~\ref{sec:undetectable-errors}), even with preceding static type checks by the TypeScript compiler, a program will be implemented, that should catch those cases while the compiled JavaScript program is running. All previously defined cases (see sec.~\ref{sec:type-check-situations}) should be honored and suitable technology should be selected to perform the required steps (see sec.~\ref{sec:required-steps}) to achieve the desired result (see sec.~\ref{sec:desired-result}).

\section{Technology}
\label{sec:technology}

The project itself will be implemented in TypeScript, while the compiled program will be executed in a \emph{Node.js\footnote{https://nodejs.org}} environment. It will be published on the \emph{npm} (i.e., node package manager) registry\footnote{https://www.npmjs.com}, a ``[...] public collection of packages of open-source code for Node.js [...]~\cite{npmjs:about}'', which should make it easy for developers to install an executable version of \emph{ts-runtime} on their system. Also other packages should be able to integrate as fast as possible with this project. This implies that both, an API (i.e., application programming interface) and a CLI (i.e., command line interface), should be provided. Furthermore, to create an application that efficiently achieves its goal, it will be important to choose appropriate tools and libraries. This includes the process of generating runtime type checks itself, as well as reflecting and checking type compatibility in the final JavaScript code. If trusted and established technology is available, that provides functionality needed for the implementation, it should be utilized to decrease development and maintenance effort and to increase the quality of the resulting project.

\subsection{TypeScript Compiler}
\label{sec:typescript-compiler}

The TypeScript compiler exposes an API to utilize its functionality programmatically. This makes it possible to read in an existing TypeScript project, perform static type checks on it and to emit a compiled JavaScript program, while having control over various aspects of this process. Several steps that are required to generate type checks for the JavaScript runtime, are provided by the TypeScript compiler. With version 2.3 an API was exposed to enable abstract syntax tree transformations~\cite{TypeScriptPullRequest:Transformation} and an issue preventing traversing the AST~\cite{TypeScriptIssue:Visitors} was resolved with version 2.4~\cite{TypeScriptPullRequest:Visitors}. Not only the ability to modify the syntax tree may be useful for the project of this thesis, also other features may be beneficial. As the project of this thesis will make use of the compiler API later in this chapter, some parts of it will be described below.

\subsubsection{Compiler Components}

To receive a runnable JavaScript program from a TypeScript project, a number of components contribute to the TypeScript compiler:~\cite[p.~251]{TypeScriptBook:Syed:2017}:
\begin{itemize}
  \item \textbf{Scanner:} The scanner is responsible for the tokenization of the source code and is controlled by the parser~\cite[p.~260]{TypeScriptBook:Syed:2017}.
  \item \textbf{Parser:} After a source file is tokenized, the parser creates an abstract syntax tree out of it~\cite[p.~263]{TypeScriptBook:Syed:2017}.
  \item \textbf{Binder:} In this part of the compiler, connections between nodes of the AST are created through \emph{symbols}~\cite[p.~267]{TypeScriptBook:Syed:2017}.
  \item \textbf{Checker:} The checker is the largest part of the TypeScript compiler and performs static type checks on the source files~\cite[p.~282]{TypeScriptBook:Syed:2017}.
  \item \textbf{Emitter:} The emitter translates the TypeScript syntax tree of the source files to plain JavaScript~\cite[p.~286]{TypeScriptBook:Syed:2017}, based on the compiler options.
\end{itemize}
These components don't have to be triggered individually when using the compiler API and a wrapper is provided, named \emph{Program}. It holds the options and source files of the current compilation~\cite[p.~254]{TypeScriptBook:Syed:2017} and provides access to the \emph{Checker}~\cite[p.~282]{TypeScriptBook:Syed:2017} and \emph{Emitter}~\cite[p.~286]{TypeScriptBook:Syed:2017}.

\subsubsection{Compiler Options}

When starting a a compilation through the TypeScript compiler API, a multitude of options~\cite{TypeScriptHandbook:CompilerOptions} may be passed. They include, but are not limited to settings for the type checking behavior, files that should be emitted, and the ECMAScript standard the resulting JavaScript code should comply to.

\subsubsection{Program}

A TypeScript project compilation can be triggered, by providing the path to a single or multiple entry files, alongside customized compiler options. All files that are referenced from the input files are loaded recursively, by making use of a \emph{compiler host}. Also it exposes the functionality, to emit the compiled JavaScript code.

\subsubsection{Compiler Host}

The compiler host abstracts, among other things, the reading and writing of input files by the \emph{Program}. By default, files will be accessed on the file system, however, a custom compiler host may be provided to a new \emph{Program}.

\subsubsection{Node}

The abstract syntax tree, created during the compilation of a TypeScript project, consists of nodes, while every node has a specific kind. A file, for example, is of kind \emph{SourceFile}, whereas a class declaration is represented by a node with the kind \emph{ClassDeclaration}.

\subsubsection{Syntax Kind}

The TypeScript API exposes an enum, named \emph{SyntaxKind}, which maps a numeric value to an AST node type (e.g.\ \emph{InterfaceDeclaration}). As every syntax tree node defines a \texttt{kind} property, containing a number from the syntax tree enumeration, it is possible to always determine the type of a node.

\subsubsection{Symbol}

A syntax tree abstracts a source file to interact with it in various ways, but it lacks relations between nodes, that are not directly connected to each other. Symbols are created to provide these relationships between such nodes. While it is possible to identify a type reference through the AST, there is no link to the declaration of the type. However, by extracting the symbol of the type reference, the node of the type declaration can be obtained.

\subsubsection{Printer}

The compiler API exposes a printer, which can create text out of an AST node recursively. Therefore it is possible to pass a \emph{SourceFile} node to the printer, and getting back a string containing TypeScript code.

% As the project of this thesis will make use of the compiler API later in this chapter, it may be of advantage to briefly describe the typical procedure of a compilation.

%To receive a runnable JavaScript program from a TypeScript project, a number of components contribute to the compilation process:~\cite[p.~251]{TypeScriptBook:Syed:2017}:
%\begin{enumerate}
%  \item \textbf{Scanner:} The scanner is responsible for the tokenization of the source code and is controlled by the parser~\cite[p.~260]{TypeScriptBook:Syed:2017}.
%  \item \textbf{Parser:} After a source file is tokenized, the parser creates an abstract syntax tree out of it~\cite[p.~263]{TypeScriptBook:Syed:2017}.
%  \item \textbf{Binder:} In this part of the compiler, connections between nodes of the AST are created through \emph{symbols}~\cite[p.~267]{TypeScriptBook:Syed:2017}.
%  \item \textbf{Checker:} The checker is the largest part of the TypeScript compiler and performs static type checks on the source files~\cite[p.~282]{TypeScriptBook:Syed:2017}.
%  \item \textbf{Emitter:} The emitter translates the TypeScript syntax to plain JavaScript~\cite[p.~286]{TypeScriptBook:Syed:2017}.
%\end{enumerate}
%These components don't have to be triggered individually when using the compiler API and a wrapper is provided, called \emph{Program}. It holds the options and source files of the current compilation~\cite[p.~254]{TypeScriptBook:Syed:2017} and provides access to the \emph{Checker}~\cite[p.~282]{TypeScriptBook:Syed:2017} and \emph{Emitter}~\cite[p.~286]{TypeScriptBook:Syed:2017}.

%\subsubsection{Compiler Components}

\subsection{Runtime Type System}
\label{sec:runtime-type-system}

A multitude of libraries are available that aim to provide a runtime type system for JavaScript and several of them were evaluated to use with \emph{ts-runtime}. Libraries that did not seem to be maintained any more were not considered.

\subsubsection{ObjectModel}

\emph{ObjectModel\footnote{https://github.com/sylvainpolletvillard/ObjectModel}} is an extensive type system, which ``[...] intends to bring strong dynamic type checking to [JavaScript] web applications~\cite{RuntimeTypeSystem:ObjectModel}''. While being actively maintained and a detailed documentation is available, several features that are required to reflect TypeScript's static type system are not included in this library, making it not entirely suitable for the use with the project of this thesis.

\subsubsection{tcomb}

The project \emph{tcomb\footnote{https://github.com/gcanti/tcomb}} argues to ``[...] check the types of JavaScript values at runtime~\cite{RuntimeTypeSystem:tcomb}''. Probably one of the most famous runtime type checking libraries for JavaScript, with more than 1300 stars on GitHub~\cite{RuntimeTypeSystem:tcomb}, it is again intended to be used for JavaScript code. Considerations especially for TypeScript are not part of this package.

\subsubsection{io-ts}

Created by Giulio Canti, the author of \emph{tcomb}, this project claims to be a ``TypeScript compatible runtime type system [...]~\cite{RuntimeTypeSystem:io-ts}''. While it did look promising to be utilized, some aspects did not meet the expectations. For example being able to define the type reflection of a class alongside the class declaration itself is not provided by the library, as well as being able to retrieve a type reference with type parameters (i.e., generics) is not possible. However, as \emph{io-ts\footnote{https://github.com/gcanti/io-ts}} may evolve over time, a transition of \emph{ts-runtime} to use it at a later point is possible.

\subsubsection{runtypes}

The \emph{runtypes\footnote{https://github.com/pelotom/runtypes}} library is a fairly young project, which wants to provide ``[r]untime validation for static types~\cite{RuntimeTypeSystem:runtypes}''. Anyway, only basic validations can be performed, compared to more comprehensive systems such as \emph{tcomb} or \emph{io-ts}. For example when asserting a value for being a function, the built in JavaScript \texttt{typeof} operator (see sec.~\ref{sec:value-types}) is used, which does not include parameter and return type compatibility.

\subsubsection{flow-runtime}

The \emph{flow-runtime\footnote{https://github.com/codemix/flow-runtime}} project states to be ``[a] runtime type system for JavaScript with full Flow compatibility~\cite{RuntimeTypeSystem:flow-runtime:lib}''. As Flow and TypeScript have a lot of similarities in syntax and features (see sec.~\ref{sec:comparison}) this library seems to be most suitable for the thesis project and to reflect the static type system of TypeScript as close as possible. Additionally \emph{flow-runtime} has a separate package, that generates type checks for Flow projects~\cite{RuntimeTypeSystem:flow-runtime:babel}, which proves that a great number of cases for Flow syntax are implemented in this package.

%\section{Tools and Libraries}
%\label{sec:tools-libraries}



%To create an application that efficiently achieves its goal, it is important to choose appropriate tools and libraries. This includes the process of generating runtime type checks itself, as well as reflecting and checking type compatibility in the final JavaScript code. If trusted and established technology is available, that provides functionality needed for the implementation, it should be utilized to decrease development and maintenance effort and to increase the quality of the resulting project.

\section{Architecture}
\label{sec:architecture}

In this section, the architecture for the application will be designed, that should already outline how the program will operate and define some of the components that will be needed:

\subsection{Central Element}

The transformation process is a sequential process, as defined in section~\ref{sec:required-steps}, which already suggests, that a central element will be needed, coordinating all different steps that should to be executed. It will be responsible for interpreting and triggering specific application logic in the appropriate situations. Before being able to initiate the actual program flow, this crucial part of the project will have to interpret different settings, including options for the TypeScript compiler. Also it will have to react to possible errors and will have to handle them adequately.

\subsection{Components}

Specific tasks will be dedicated to separate components, which contain the logic for a selected purpose, to keep the project extensible and maintainable.

\subsubsection{Options}

It will be beneficial to control the behavior of \emph{ts-runtime}, when initiating a transformation process. While the program should provide sensible defaults, it should be possible to optionally overwrite these default settings, by passing the desired options to the application.

\subsubsection{Event Bus}

Some of the components of the application will have access to other components and their API, whereas other parts of the program won't know the state of the transformation process. It might be necessary to observe, or to get notified, if a condition changes, where an event bus will be of advantage. Consequently, the event bus (i.e., bus) should be accessible globally. 

\subsubsection{Scanner}

Not to confuse with the scanner of the TypeScript compiler (see sec.~\ref{sec:typescript-compiler}), this component of the thesis project should scan the abstract tree of the source files. Ambient and external declarations should be identified, that won't be included in the compiled program, but need to be reflected in order to guarantee that type checks can take place during runtime. Also identifier names across all source files should be stored, to avoid duplicate identifiers when introducing new variables during the insertion of runtime type checks.

\subsubsection{Mutators}

For every situation where runtime type checks should be generated (see sec.~\ref{sec:type-check-situations}), a mutator should exist, that performs the modification or substitution of the AST node.

\subsubsection{Factory}

To avoid code duplication, the factory should provide a collection of common transformations performed on syntax tree nodes. It will be utilized by the mutators, to keep their footprint as small as possible and to reduce code complexity.

\subsubsection{Context}

As not all components of the application are connected to each other, the context should provide a centralized gateway to information, that might be required in the mutators or the factory. It should, among other things, have knowledge of the current source file being processed, the options of the application and the TypeScript compiler program.

\subsubsection{Utilities}

Miscellaneous functionality, that does not require any link to the state of the program, should be collected in the utilities of \emph{ts-runtime}. It should be available from any location of the project.

%\begin{itemize}
%  \item \textbf{Options:} It will be beneficial to control the behavior of \emph{ts-runtime}, when initiating a transformation process. While the program should provide sensible defaults, it should be possible to optionally overwrite these default settings, by passing the desired options to the application.
%  \item \textbf{Event Bus:} Some of the components of the application will have access to other components and their API, whereas other parts of the program won't know the state of the transformation process. It might be necessary to observe, or to get notified, if a condition changes, where an event bus will be of advantage. Consequently, the event bus (i.e., bus) should be accessible globally. 
%  \item \textbf{Scanner:} Not to confuse with the scanner of the TypeScript compiler (see sec.~\ref{sec:typescript-compiler}), this component of the thesis project should scan the abstract tree of the source files. Ambient and external declarations should be identified, that won't be included in the compiled program, but need to be reflected in order to guarantee that type checks can take place during runtime. Also identifier names across all source files should be stored, to avoid duplicate identifiers when introducing new variables during the insertion of runtime type checks.
%  \item \textbf{Mutators:} For every situation where runtime type checks should be generated (see sec.~\ref{sec:type-check-situations}), a mutator should exist, that performs the modification or substitution of the AST node.
%  \item \textbf{Factory:} To avoid code duplication, the factory should provide a collection of common transformations performed on syntax tree nodes. It will be utilized by the mutators, to keep their footprint as small as possible and to reduce their code complexity.
%  \item \textbf{Context:} As not all components of the application are connected to each other, the context should provide a centralized gateway to information, that might be required in the mutators or the factory. It should, among other things, have knowledge of the current source file being processed, the options of the application and the TypeScript compiler program.
%  \item \textbf{Utilities:} Miscellaneous functionality, that does not require any link to the state of the program, should be collected in the utilities of \emph{ts-runtime}. It should be available from any location of the project.
%\end{itemize}

\subsection{Outline}

After the main parts of the program have been defined, it is possible to draw connection between them (see fig.~\ref{fig:architecture}).
\begin{figure}
\centering
\includestandalone{assets/diagrams/architecture}
\caption{Component architecture of the thesis project.}
\label{fig:architecture}
\end{figure}
As already stated, the central element (i.e., core) of the application controls the program flow, therefore having knowledge and access to all components of \emph{ts-runtime}. It evaluates the options, creates a TypeScript compiler program (see sec.~\ref{sec:typescript-compiler}) and triggers the scanning and transforming of the syntax tree, before emitting a compiled JavaScript project with inserted runtime type checks. 

%\subsection{Event Bus}
%
%Some of the components of the application will have access to other components and their API, whereas other parts of the program won't know the state of the transformation process. It might be necessary to observe, or get notified, if a condition changes, where an event bus could be of advantage.
%
%\subsection{Scanning}
%
%After ensuring, that all input is valid and an abstraction of the source files from a TypeScript project to transform could be created without errors, the abstraction can be scanned. In this part of the program, ambient and external declarations will be identified, that won't be included in the compiled program, but need to be reflected in order to guarantee that type checks can take place during runtime. Also all identifier names accross source files should be remembered, to avoid duplicate identifiers when introducing new variables during the insertion of runtime type checks.
%
%\subsection{Modifications}
%
%The required information to proceed with the actual modifications on the source file abstractions should now be available.

%\begin{itemize}
%  \item \textbf{Core:} The transformation process is a sequential process, as defined in section~\ref{sec:required-steps}, which already suggests, that a central element will be needed, coordinating all different steps that should to be executed. It will be responsible for interpreting and triggering specific application logic in the appropriate situations. Before being able to initiate the actual program flow, this crucial part of the project will have to interpret different settings, including options for the TypeScript compiler. Also it will have to react to possible errors and will have to handle them adequately.
%  \item \textbf{Scanner:} After ensuring, that all input is valid and an abstraction of the source files from a TypeScript project to transform could be created without errors, the abstraction can be scanned. In this part of the program, ambient and external declarations will be identified, that won't be included in the compiled program, but need to be reflected in order to guarantee that type checks can take place during runtime. Also all identifier names accross source files should be remembered, to avoid duplicate identifiers when introducing new variables during the insertion of runtime type checks.
%  \item \textbf{Mutator:} The required information to proceed with the actual modifications on the source file abstractions should now be available.
%\end{itemize}

%\section{Tools and Libraries}
%\label{sec:tools-libraries}
%
%To create an application that efficiently achieves its goal, it is important to choose appropriate tools and libraries. This includes the process of generating runtime type checks itself, as well as reflecting and checking type compatibility in the final JavaScript code. If trusted and established technology is available, that provides functionality needed for the implementation, it should be utilized to decrease development and maintenance effort and to increase the quality of the resulting project.
%
%\subsection{TypeScript Compiler API}
%
%Several steps that are required to generate type checks for the JavaScript runtime, are provided by the TypeScript compiler API, as of version 2.4. An API was exposed to enable abstract syntax tree transformations with version 2.3~\cite{TypeScriptPullRequest:Transformation} and an issue, preventing traversing the AST, was resolved with version 2.4~\cite{TypeScriptIssue:Visitors}.

%\subsection{Runtime Type System}
%
%\section{Architecture}
%\label{sec:architecture}

\section{Application Structure}
\label{sec:structure}

The following directory structure will be used for \emph{ts-runtime}, which at the same time shows the most important files and folders of the project:
\dirtree{%
.1 /src.
.2 bin\DTcomment{Command Line Interface}.
.2 lib\DTcomment{Runtime Type Checking Library}.
.2 mutators\DTcomment{AST Node Transformers}.
.2 bus.ts\DTcomment{Event Bus}.
.2 context.ts\DTcomment{Mutation Context}.
.2 index.ts\DTcomment{API Exposure}.
.2 factory.ts\DTcomment{Common AST Node Transformations}.
.2 options.ts\DTcomment{Default Options}.
.2 scanner.ts\DTcomment{AST Scanner}.
.2 transform.ts\DTcomment{Application Core}.
.2 util.ts\DTcomment{Miscellaneous Utilities}.
}

\section{Components}
\label{sec:components}


In this section the implementation of the core of the project, as well as the application's components, will be described. The main focus will be on challenges that had to be overcome, and on the interconnections of the different parts of the program.

\subsection{Transformer}

The \emph{Transformer}, located in \texttt{src/transformer.ts}, is the core of the thesis project and exposes three methods, that may be utilized via the project's API:
\begin{itemize}
  \item \texttt{\textbf{getOptions:}} This function accepts an object as parameter, that aligns with the \emph{Options} interface, described later in this section. It then merges the passed object with the default settings, and returns the result. This ensures, that all required options are contained in the resulting object.
  \item \texttt{\textbf{transform:}} By calling this method, a transformation process is initiated. It is required to pass at least a list of entry file names. Optionally, an \emph{Options} object may be passed as well. Nothing is returned, but the compiled JavaScript files are written to disk, according to the TypeScript compiler options, if no errors occurred.
  \item \texttt{\textbf{transformReflection:}} The \texttt{transform} function loads the list of files from disk, which requires a file system to be present. On the contrary, this method accepts a list of file reflections, that must include the passed entry files, as well as all modules referenced, recursively. This enables the application, to act without a real file system. Also the target code is not persisted, but a list of file reflections, containing the compilation result, is returned.
\end{itemize}
Program~\ref{prog:transform} shows a, reduced to its essentials, version of the \texttt{transform} function.
\begin{program}
\caption{The \texttt{transform} function of the project's core, reduced to its essentials. The \texttt{ts} namespace from line~\ref{prog:transform:ts1} and~\ref{prog:transform:ts2} point to the TypeScript API.}
\label{prog:transform}
\begin{JsCode}
function transform(entryFiles: string[], options?: Options} {
  const opts = getOptions(options);
  const program = ts.createProgram(entryFiles, opts.compilerOptions); /+\label{prog:transform:ts1}+/
  const scanner = new Scanner(program, opts);
  const files = program.getSourceFiles();
  const result = ts.transform(files, [transformer], opts.compilerOptions); /+\label{prog:transform:ts2}+/ /+\label{prog:transform:transformer}+/
  emit(result);
}
\end{JsCode}
\end{program}
%TODO: Add ref
It is not fully functional, but should give an idea of the program flow. On line~\ref{prog:transform:transformer}, a variable \texttt{transformer} is passed to a function from the TypeScript compiler API. This identifier references a function, that visits every node of the AST of all source files from the TypeScript program. The function code, again simplified, is shown in program~\ref{prog:transformer}, while line~\ref{prog:transformer:mutate} indicates the AST node being passed to the mutators of \emph{ts-runtime}, possibly returning a substitution.
\begin{program}
\caption{}
\label{prog:transformer}
\begin{JsCode}
function transformer() {
  let context: MutationContext;
  
  const visitor = node => {
    node = mutate(node, context); /+\label{prog:transformer:mutate}+/
    return ts.visitEachChild(node);
  }
  
  return sourceFile => {
    context = createContext(sourceFile);
    return ts.visitNode(sourceFile, visitor);
  };
}
\end{JsCode}
\end{program}
Technically, the abstract syntax tree node's children are followed to the very bottom before applying mutations on them. This should assure, that every transformation already includes modifications from its child nodes, also preventing additions to the tree from being processed.


\subsection{Mutators}
% describe base mutator

Every mutator of the project, extends a base mutator, that provides a simplified API, which is utilized by the core (i.e., \emph{Transformer}) of the project. Therefore each mutator must cohere with its base, which in its simplest form may look like the code below:
\begin{JsCode}[numbers=none]
class InterfaceMutator extends Mutator {

  protected kind = ts.SyntaxKind.InterfaceDeclaration;
  
  protected mutate(node: ts.InterfaceDeclaration): ts.Node {
    return node;
  }

}
\end{JsCode}
A valid mutator must define a \texttt{kind} property, containing a syntax kind---or a list (i.e., array) of syntax kinds---to define which node types the mutator is able to process. Additionally, also a method \texttt{mutate} must exist on a mutator. This function accepts a single parameter, which is the node to be processed. The mutator may then perform modifications on it, or can replace the node entirely. Each mutator is meant to be used through the method \texttt{mutateNode}, defined by the base class API. This ensures that the following checks are performed to discover, if the node should be processed:
\begin{enumerate}
  \item Is the kind of the node supported by the mutator?
  \item Is the node flagged to be skipped?
  \item Is the node declared ambient, using the \texttt{declare} keyword?
\end{enumerate}
If all of these checks pass, the actual \texttt{mutate} method is called. If, however, any of the conditions from above could not be met, the original node is returned untouched. Based on the defined cases from section~\ref{sec:type-check-situations}, the following mutators were implemented, located in \texttt{src/mutators} and also showing their file names without an extension:
\begin{itemize}
  \item ArrowFunctionMutator
  \item AsExpressionMutator
  \item BinaryExpressionMutator
  \item BlockLikeMutator
  \item ClassDeclarationMutator
  \item FunctionDeclarationMutator
  \item FunctionExpressionMutator
  \item InterfaceDeclarationMutator
  \item SourceFileMutator
  \item TypeAliasDeclarationMutator
  \item VariableDeclarationListMutator
\end{itemize}
Some of the implementations were more complex than others and special cases had to be taken into account. While every mutator will be outlined, a few of them will be handled in more detail.

\subsubsection{Arrow Function Mutator}

The arrow function mutator has to modify the body of the passed node, while some peculiarities have to be considered. As for every other function type (i.e., function expression and function declarations), the parameters have to be asserted, while they can be optional or may have a default value. Also every location where the function may return a value has to be observed and checked. A major difference to function expressions is, that they may omit a function body, previously described in section~\ref{sec:latest-improvements}, it has to be created in order to insert runtime type checks. Because of the arrow function mutator being relatively small, compared to other mutators, it is shown in program~\ref{prog:mutator:arrow-function}.
\begin{program}
\caption{The arrow function mutator of \emph{ts-runtime}.}
\label{prog:mutator:arrow-function}
\begin{JsCode}
export class ArrowFunctionMutator extends Mutator {

  protected kind = ts.SyntaxKind.ArrowFunction;

  protected mutate(node: ts.ArrowFunction): ts.CallExpression {
    return this.factory.annotate(
      this.factory.mutateFunctionBody(node), /+\label{prog:mutator:arrow-function:mutate-body}+/
      this.factory.functionReflection(node) /+\label{prog:mutator:arrow-function:reflect}+/
    );
  }

}
\end{JsCode}
\end{program}
Analyzing the code of the class, it obviously makes use of the factory, that will be described later in this chapter. Alongside changing the arrow function's body, it is also annotated. This means, that a reflection of the function, including its parameters and the return type, will be added to the function object, to retrieve it in other places of the running program. To better describe, how the result of a transformation may look like, the following arrow function is given. 
\begin{JsCode}[numbers=none]
(): string => "bar";
\end{JsCode}
The call to \texttt{mutateFunctionBody} in program~\ref{prog:mutator:arrow-function} on line~\ref{prog:mutator:arrow-function:mutate-body} returns a node, that transforms the function to the following:
\begin{JsCode}[numbers=none]
() => {
  const _returnType = t.return(t.string());
  return _returnType.assert("bar");
}
\end{JsCode}
Also a description of the function signature is retrieved via \texttt{functionReflection} on line~\ref{prog:mutator:arrow-function:reflect}, that is represented with:
\begin{JsCode}[numbers=none]
t.function(t.return(t.string()));
\end{JsCode}
Furthermore, the arrow function is annotated with this reflection. As in most cases a function expression would be assigned to a variable, the code below could be the result of the transformation:
\begin{JsCode}[numbers=none]
const foo = t.annotate(() => {
  const _returnType = t.return(t.string());
  return _returnType.assert("bar");
}, t.function(t.return(t.string())));
\end{JsCode}
The variable \texttt{foo} now holds the arrow function, with added information about its signature. The type of the identifier may then be used to declare another variable, like in the following code snippet:
\begin{JsCode}[numbers=none]
const bar: typeof foo = (): string => "hi";
\end{JsCode}
This results in the following code in the compiled JavaScript program:
\begin{JsCode}[numbers=none]
const bar = t.typeOf(foo).assert(/* transformed arrow function */);
\end{JsCode}
A function \texttt{t.typeOf}---part of the \emph{flow-runtime} library---is called with \texttt{foo}, which extracts the previously annotated information. Therefore it can be checked, if the value that should be assigned to \texttt{bar}, matches the type of \texttt{foo}. Otherwise it could only be verified, if the value is a function, which is unsatisfactory to ensure type compatibility.

\subsubsection{As Expression Mutator}

Also TypeScript type assertions should be asserted at runtime. This means that if a value is casted to another type, it should be validated if the value actually is compatible with this type:
\begin{JsCode}[numbers=none]
"foo" as number;
\end{JsCode}
The code from above will therefore be substituted with the one below:
\begin{JsCode}[numbers=none]
t.number().assert("foo");
\end{JsCode}
While the assertion used in this example already raises an error when being statically checked by the TypeScript compiler, there are situations where a cast can be performed successfully, even though types do not match (see sec.~\ref{sec:undetectable-errors}).

\subsubsection{Binary Expression Mutator}

Binary expressions in JavaScript (and TypeScript) include, but are not limited to, assignments, comparisons and bitwise operations~\cite{expressions-and-operators:MDN:2017}. However, the mutator which is handling such nodes, is only considering assignment operations. It is worth to note that an expression with an assignment operator is a different AST node, than a variable declaration with an initializer. Anyway, the outcome of the transformation is very similar, therefore being pictured later in this section.

\subsubsection{Block Like Mutator}

The transformation API of the TypeScript compiler allows for substituting AST nodes, by returning any node from a tree visitor. While this functionality is heavily used in the project of this thesis, it does only allow to replace a node with exactly one node. There are cases that require mutators to add a new node alongside another one. These situations include function, class and enum declarations. As shown in the mutator for arrow functions, they are annotated with their signature reflection.
Also function declarations have to be annotated in this way, but it is not possible to wrap them into another function call, as this would change the scope of the declaration (see sec.~\ref{sec:latest-improvements}). Because of that the annotation should be added beneath the function declaration itself.
The same applies to enumerations, as they are initialized by a self executing function in the target code (see sec.~\ref{sec:type-check-situations}). Also there is no information available about the variable that will hold the enum object after the TypeScript compiler emits the final JavaScript code, during transformation. This means, that the annotation should take place after the initialization of the runtime representation of the enumeration.
For classes the situation is different. Decorators can be used to annotate the class, but its type parameters need to be available before the first instantiation, to make use of them in the class signature reflection:
\begin{JsCode}[numbers=none]
class A<T> { }
\end{JsCode}
The class from above will result in the following transformation by the block-like mutator:
\begin{JsCode}[numbers=none]
const _ATypeParametersSymbol = Symbol("ATypeParameters");
class A<T> { }
\end{JsCode}
The main focus of this example is on the first line of the snippet, therefore the class transformation itself was omitted, where a symbol for the class's type parameters is declared, to expose it to the same scope as of the class. How this symbol is further used, will be described in the ensuing section.

\subsubsection{Class Declaration Mutator}

The class declaration mutator is one of the most complex. It has to consider various situations, including that a class may extend another class, implement interfaces, can have method and non-method properties, may include function overloads~\cite{TypeScriptHandbook:Functions}, and can merge with interface declarations~\cite{TypeScriptHandbook:DeclarationMerging}. Also class members may have modifiers such as \emph{static}, \emph{readonly}, \emph{public}, \emph{private} and \emph{protected}.


\subsubsection{Function Declaration Mutator}

% GENERICS

\subsubsection{Interface Expression Mutator}

\subsubsection{Source File Mutator}

\subsubsection{Type Alias Declaration Mutator}

\subsubsection{Variable Declaration List Mutator}

%Based on the definition of cases, where type reflections and assertions need to be performed, described in section~\ref{sec:type-check-situations}, 

% Itemize all mutators

\subsection{Options}

\subsection{Event Bus}

\subsection{Scanner}

\subsection{Factory}

\subsection{Utilities}

%\section{Transformation Results}
%\label{sec:transformation-results}
%
%\subsection{SourceFile}
%
%\subsection{Variables}
%
%\subsection{Type Assertions}
%
%\subsection{Functions}
%
%\subsection{Type Queries}
%
%\subsection{Enumerations}
%
%\subsection{Type Aliases}
%
%\subsection{Interfaces}
%
%\subsection{Classes}
%
%\subsection{Method Overloads}
%
%\subsection{Generics}
%
%\subsection{Externals}
%
%\subsection{Ambient Declarations}

\section{Program Procedure}
\label{sec:program-procedure}

\section{Usage}
\label{sec:usage}

\subsection{Programming Interface}
\label{sec:usage-api}

\subsection{Command Line Interface}
\label{sec:usage-cli}
