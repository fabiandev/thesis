
\chapter{Implementation}
\label{cha:implementation}

After elaborating situations where runtime errors may occur in the previous chapter (see sec.~\ref{sec:undetectable-errors}), even with preceding static type checks by the TypeScript compiler, a program will be implemented, that should catch those cases while the compiled JavaScript program is running. All previously defined cases (see sec.~\ref{sec:type-check-situations}) should be honored and suitable technology should be selected to perform the required steps (see sec.~\ref{sec:required-steps}) to achieve the desired result (see sec.~\ref{sec:desired-result}).

\section{Technology}
\label{sec:technology}

The project itself will be implemented in TypeScript, while the compiled program will be executed in a \emph{Node.js\footnote{https://nodejs.org}} environment. It will be published on the \emph{npm} (i.e., node package manager) registry\footnote{https://www.npmjs.com}, a ``[...] public collection of packages of open-source code for Node.js [...]~\cite{npmjs:about}'', which should make it easy for developers to install an executable version of \emph{ts-runtime} on their system. Also other packages should be able to integrate as fast as possible with this project. This implies that both, an API (i.e., application programming interface) and a CLI (i.e., command line interface), should be provided. Furthermore, to create an application that efficiently achieves its goal, it will be important to choose appropriate tools and libraries. This includes the process of generating runtime type checks itself, as well as reflecting and checking type compatibility in the final JavaScript code. If trusted and established technology is available, that provides functionality needed for the implementation, it should be utilized to decrease development and maintenance effort and to increase the quality of the resulting project.

\subsection{TypeScript Compiler}
\label{sec:typescript-compiler}

The TypeScript compiler exposes an API to utilize its functionality programmatically. This makes it possible to read in an existing TypeScript project, perform static type checks on it and to emit a compiled JavaScript program, while having control over various aspects of this process. Several steps that are required to generate type checks for the JavaScript runtime, are provided by the TypeScript compiler. With version 2.3 an API was exposed to enable abstract syntax tree transformations~\cite{TypeScriptPullRequest:Transformation} and an issue preventing traversing the AST~\cite{TypeScriptIssue:Visitors} was resolved with version 2.4~\cite{TypeScriptPullRequest:Visitors}. Not only the ability to modify the syntax tree may be useful for the project of this thesis, also other features may be beneficial. As the project of this thesis will make use of the compiler API later in this chapter, some parts of it will be described below.

\subsubsection{Compiler Components}

To receive a runnable JavaScript program from a TypeScript project, a number of components contribute to the TypeScript compiler:~\cite[p.~251]{TypeScriptBook:Syed:2017}:
\begin{itemize}
  \item \textbf{Scanner:} The scanner is responsible for the tokenization of the source code and is controlled by the parser~\cite[p.~260]{TypeScriptBook:Syed:2017}.
  \item \textbf{Parser:} After a source file is tokenized, the parser creates an abstract syntax tree out of it~\cite[p.~263]{TypeScriptBook:Syed:2017}.
  \item \textbf{Binder:} In this part of the compiler, connections between nodes of the AST are created through \emph{symbols}~\cite[p.~267]{TypeScriptBook:Syed:2017}.
  \item \textbf{Checker:} The checker is the largest part of the TypeScript compiler and performs static type checks on the source files~\cite[p.~282]{TypeScriptBook:Syed:2017}.
  \item \textbf{Emitter:} The emitter translates the TypeScript syntax tree of the source files to plain JavaScript~\cite[p.~286]{TypeScriptBook:Syed:2017}, based on the compiler options.
\end{itemize}
These components don't have to be triggered individually when using the compiler API and a wrapper is provided, named \emph{Program}. It holds the options and source files of the current compilation~\cite[p.~254]{TypeScriptBook:Syed:2017} and provides access to the \emph{Checker}~\cite[p.~282]{TypeScriptBook:Syed:2017} and \emph{Emitter}~\cite[p.~286]{TypeScriptBook:Syed:2017}.

\subsubsection{Compiler Options}

When starting a a compilation through the TypeScript compiler API, a multitude of options~\cite{TypeScriptHandbook:CompilerOptions} may be passed. They include, but are not limited to settings for the type checking behavior, files that should be emitted, and the ECMAScript standard the resulting JavaScript code should comply to.

\subsubsection{Program}

A TypeScript project compilation can be triggered, by providing the path to a single or multiple entry files, alongside customized compiler options. All files that are referenced from the input files are loaded recursively, by making use of a \emph{compiler host}. Also it exposes the functionality, to emit the compiled JavaScript code.

\subsubsection{Compiler Host}

The compiler host abstracts, among other things, the reading and writing of input files by the \emph{Program}. By default, files will be accessed on the file system, however, a custom compiler host may be provided to a new \emph{Program}.

\subsubsection{Node}

The abstract syntax tree, created during the compilation of a TypeScript project, consists of nodes, while every node has a specific kind. A file, for example, is of kind \emph{SourceFile}, whereas a class declaration is represented by a node with the kind \emph{ClassDeclaration}.

\subsubsection{Symbol}

A syntax tree abstracts a source file to interact with it in various ways, but it lacks relations between nodes, that are not directly connected to each other. Symbols are created to provide these relationships between such nodes. While it is possible to identify a type reference through the AST, there is no link to the declaration of the type. However, by extracting the symbol of the type reference, the node of the type declaration can be obtained.

\subsubsection{Printer}

The compiler API exposes a printer, which can create text out of an AST node recursively. Therefore it is possible to pass a \emph{SourceFile} node to the printer, and getting back a string containing TypeScript code.

% As the project of this thesis will make use of the compiler API later in this chapter, it may be of advantage to briefly describe the typical procedure of a compilation.

%To receive a runnable JavaScript program from a TypeScript project, a number of components contribute to the compilation process:~\cite[p.~251]{TypeScriptBook:Syed:2017}:
%\begin{enumerate}
%  \item \textbf{Scanner:} The scanner is responsible for the tokenization of the source code and is controlled by the parser~\cite[p.~260]{TypeScriptBook:Syed:2017}.
%  \item \textbf{Parser:} After a source file is tokenized, the parser creates an abstract syntax tree out of it~\cite[p.~263]{TypeScriptBook:Syed:2017}.
%  \item \textbf{Binder:} In this part of the compiler, connections between nodes of the AST are created through \emph{symbols}~\cite[p.~267]{TypeScriptBook:Syed:2017}.
%  \item \textbf{Checker:} The checker is the largest part of the TypeScript compiler and performs static type checks on the source files~\cite[p.~282]{TypeScriptBook:Syed:2017}.
%  \item \textbf{Emitter:} The emitter translates the TypeScript syntax to plain JavaScript~\cite[p.~286]{TypeScriptBook:Syed:2017}.
%\end{enumerate}
%These components don't have to be triggered individually when using the compiler API and a wrapper is provided, called \emph{Program}. It holds the options and source files of the current compilation~\cite[p.~254]{TypeScriptBook:Syed:2017} and provides access to the \emph{Checker}~\cite[p.~282]{TypeScriptBook:Syed:2017} and \emph{Emitter}~\cite[p.~286]{TypeScriptBook:Syed:2017}.

%\subsubsection{Compiler Components}

\subsection{Runtime Type System}
\label{sec:runtime-type-system}

A multitude of libraries are available that aim to provide a runtime type system for JavaScript and several of them were evaluated to use with \emph{ts-runtime}. Libraries that did not seem to be maintained any more were not considered.

\subsubsection{ObjectModel}

\emph{ObjectModel\footnote{https://github.com/sylvainpolletvillard/ObjectModel}} is an extensive type system, which ``[...] intends to bring strong dynamic type checking to [JavaScript] web applications~\cite{RuntimeTypeSystem:ObjectModel}''. While being actively maintained and a detailed documentation is available, several features that are required to reflect TypeScript's static type system are not included in this library, making it not entirely suitable for the use with the project of this thesis.

\subsubsection{tcomb}

The project \emph{tcomb\footnote{https://github.com/gcanti/tcomb}} argues to ``[...] check the types of JavaScript values at runtime~\cite{RuntimeTypeSystem:tcomb}''. Probably one of the most famous runtime type checking libraries for JavaScript, with more than 1300 stars on GitHub~\cite{RuntimeTypeSystem:tcomb}, it is again intended to be used for JavaScript code. Considerations especially for TypeScript are not part of this package.

\subsubsection{io-ts}

Created by Giulio Canti, the author of \emph{tcomb}, this project claims to be a ``TypeScript compatible runtime type system [...]~\cite{RuntimeTypeSystem:io-ts}''. While it did look promising to be utilized, some aspects did not meet the expectations. For example being able to define the type reflection of a class alongside the class declaration itself is not provided by the library, as well as being able to retrieve a type reference with type parameters (i.e., generics) is not possible. However, as \emph{io-ts\footnote{https://github.com/gcanti/io-ts}} may evolve over time, a transition of \emph{ts-runtime} to use it at a later point is possible.

\subsubsection{runtypes}

The \emph{runtypes\footnote{https://github.com/pelotom/runtypes}} library is a fairly young project, which wants to provide ``[r]untime validation for static types~\cite{RuntimeTypeSystem:runtypes}''. Anyway, only basic validations can be performed, compared to more comprehensive systems such as \emph{tcomb} or \emph{io-ts}. For example when asserting a value for being a function, the built in JavaScript \texttt{typeof} operator (see sec.~\ref{sec:value-types}) is used, which does not include parameter and return type compatibility.

\subsubsection{flow-runtime}

The \emph{flow-runtime\footnote{https://github.com/codemix/flow-runtime}} project states to be ``[a] runtime type system for JavaScript with full Flow compatibility~\cite{RuntimeTypeSystem:flow-runtime:lib}''. As Flow and TypeScript have a lot of similarities in syntax and features (see sec.~\ref{sec:comparison}) this library seems to be most suitable for the thesis project and to reflect the static type system of TypeScript as close as possible. Additionally \emph{flow-runtime} has a separate package, that generates type checks for Flow projects~\cite{RuntimeTypeSystem:flow-runtime:babel}, which proves that a great number of cases for Flow syntax are implemented in this package.

%\section{Tools and Libraries}
%\label{sec:tools-libraries}



%To create an application that efficiently achieves its goal, it is important to choose appropriate tools and libraries. This includes the process of generating runtime type checks itself, as well as reflecting and checking type compatibility in the final JavaScript code. If trusted and established technology is available, that provides functionality needed for the implementation, it should be utilized to decrease development and maintenance effort and to increase the quality of the resulting project.

\section{Architecture}
\label{sec:architecture}

In this section, the architecture for the application will be designed, that should already outline how the program will operate and define some of the components that will be needed:

\subsection{Central Element}

The transformation process is a sequential process, as defined in section~\ref{sec:required-steps}, which already suggests, that a central element will be needed, coordinating all different steps that should to be executed. It will be responsible for interpreting and triggering specific application logic in the appropriate situations. Before being able to initiate the actual program flow, this crucial part of the project will have to interpret different settings, including options for the TypeScript compiler. Also it will have to react to possible errors and will have to handle them adequately.

\subsection{Components}

Specific tasks will be dedicated to separate components, which contain the logic for a selected purpose, to keep the project extensible and maintainable.

\subsubsection{Options}

It will be beneficial to control the behavior of \emph{ts-runtime}, when initiating a transformation process. While the program should provide sensible defaults, it should be possible to optionally overwrite these default settings, by passing the desired options to the application.

\subsubsection{Event Bus}

Some of the components of the application will have access to other components and their API, whereas other parts of the program won't know the state of the transformation process. It might be necessary to observe, or to get notified, if a condition changes, where an event bus will be of advantage. Consequently, the event bus (i.e., bus) should be accessible globally. 

\subsubsection{Scanner}

Not to confuse with the scanner of the TypeScript compiler (see sec.~\ref{sec:typescript-compiler}), this component of the thesis project should scan the abstract tree of the source files. Ambient and external declarations should be identified, that won't be included in the compiled program, but need to be reflected in order to guarantee that type checks can take place during runtime. Also identifier names across all source files should be stored, to avoid duplicate identifiers when introducing new variables during the insertion of runtime type checks.

\subsubsection{Mutators}

For every situation where runtime type checks should be generated (see sec.~\ref{sec:type-check-situations}), a mutator should exist, that performs the modification or substitution of the AST node.

\subsubsection{Factory}

To avoid code duplication, the factory should provide a collection of common transformations performed on syntax tree nodes. It will be utilized by the mutators, to keep their footprint as small as possible and to reduce code complexity.

\subsubsection{Context}

As not all components of the application are connected to each other, the context should provide a centralized gateway to information, that might be required in the mutators or the factory. It should, among other things, have knowledge of the current source file being processed, the options of the application and the TypeScript compiler program.

\subsubsection{Utilities}

Miscellaneous functionality, that does not require any link to the state of the program, should be collected in the utilities of \emph{ts-runtime}. It should be available from any location of the project.

%\begin{itemize}
%  \item \textbf{Options:} It will be beneficial to control the behavior of \emph{ts-runtime}, when initiating a transformation process. While the program should provide sensible defaults, it should be possible to optionally overwrite these default settings, by passing the desired options to the application.
%  \item \textbf{Event Bus:} Some of the components of the application will have access to other components and their API, whereas other parts of the program won't know the state of the transformation process. It might be necessary to observe, or to get notified, if a condition changes, where an event bus will be of advantage. Consequently, the event bus (i.e., bus) should be accessible globally. 
%  \item \textbf{Scanner:} Not to confuse with the scanner of the TypeScript compiler (see sec.~\ref{sec:typescript-compiler}), this component of the thesis project should scan the abstract tree of the source files. Ambient and external declarations should be identified, that won't be included in the compiled program, but need to be reflected in order to guarantee that type checks can take place during runtime. Also identifier names across all source files should be stored, to avoid duplicate identifiers when introducing new variables during the insertion of runtime type checks.
%  \item \textbf{Mutators:} For every situation where runtime type checks should be generated (see sec.~\ref{sec:type-check-situations}), a mutator should exist, that performs the modification or substitution of the AST node.
%  \item \textbf{Factory:} To avoid code duplication, the factory should provide a collection of common transformations performed on syntax tree nodes. It will be utilized by the mutators, to keep their footprint as small as possible and to reduce their code complexity.
%  \item \textbf{Context:} As not all components of the application are connected to each other, the context should provide a centralized gateway to information, that might be required in the mutators or the factory. It should, among other things, have knowledge of the current source file being processed, the options of the application and the TypeScript compiler program.
%  \item \textbf{Utilities:} Miscellaneous functionality, that does not require any link to the state of the program, should be collected in the utilities of \emph{ts-runtime}. It should be available from any location of the project.
%\end{itemize}

\subsection{Outline}

After the main parts of the program have been defined, it is possible to draw connection between them (see fig.~\ref{fig:architecture}).
\begin{figure}
\centering
\includestandalone{assets/diagrams/architecture}
\caption{Component architecture of the thesis project.}
\label{fig:architecture}
\end{figure}
As already stated, the central element (i.e., core) of the application controls the program flow, therefore having knowledge and access to all components of \emph{ts-runtime}. It evaluates the options, creates a TypeScript compiler program (see sec.~\ref{sec:typescript-compiler}) and triggers the scanning and transforming of the syntax tree, before emitting a compiled JavaScript project with inserted runtime type checks. 

%\subsection{Event Bus}
%
%Some of the components of the application will have access to other components and their API, whereas other parts of the program won't know the state of the transformation process. It might be necessary to observe, or get notified, if a condition changes, where an event bus could be of advantage.
%
%\subsection{Scanning}
%
%After ensuring, that all input is valid and an abstraction of the source files from a TypeScript project to transform could be created without errors, the abstraction can be scanned. In this part of the program, ambient and external declarations will be identified, that won't be included in the compiled program, but need to be reflected in order to guarantee that type checks can take place during runtime. Also all identifier names accross source files should be remembered, to avoid duplicate identifiers when introducing new variables during the insertion of runtime type checks.
%
%\subsection{Modifications}
%
%The required information to proceed with the actual modifications on the source file abstractions should now be available.

%\begin{itemize}
%  \item \textbf{Core:} The transformation process is a sequential process, as defined in section~\ref{sec:required-steps}, which already suggests, that a central element will be needed, coordinating all different steps that should to be executed. It will be responsible for interpreting and triggering specific application logic in the appropriate situations. Before being able to initiate the actual program flow, this crucial part of the project will have to interpret different settings, including options for the TypeScript compiler. Also it will have to react to possible errors and will have to handle them adequately.
%  \item \textbf{Scanner:} After ensuring, that all input is valid and an abstraction of the source files from a TypeScript project to transform could be created without errors, the abstraction can be scanned. In this part of the program, ambient and external declarations will be identified, that won't be included in the compiled program, but need to be reflected in order to guarantee that type checks can take place during runtime. Also all identifier names accross source files should be remembered, to avoid duplicate identifiers when introducing new variables during the insertion of runtime type checks.
%  \item \textbf{Mutator:} The required information to proceed with the actual modifications on the source file abstractions should now be available.
%\end{itemize}

%\section{Tools and Libraries}
%\label{sec:tools-libraries}
%
%To create an application that efficiently achieves its goal, it is important to choose appropriate tools and libraries. This includes the process of generating runtime type checks itself, as well as reflecting and checking type compatibility in the final JavaScript code. If trusted and established technology is available, that provides functionality needed for the implementation, it should be utilized to decrease development and maintenance effort and to increase the quality of the resulting project.
%
%\subsection{TypeScript Compiler API}
%
%Several steps that are required to generate type checks for the JavaScript runtime, are provided by the TypeScript compiler API, as of version 2.4. An API was exposed to enable abstract syntax tree transformations with version 2.3~\cite{TypeScriptPullRequest:Transformation} and an issue, preventing traversing the AST, was resolved with version 2.4~\cite{TypeScriptIssue:Visitors}.

%\subsection{Runtime Type System}
%
%\section{Architecture}
%\label{sec:architecture}

\section{Application Structure}
\label{sec:structure}

The following directory structure will be used for \emph{ts-runtime}, which at the same time shows the most important files and folders of the project:
\dirtree{%
.1 /src.
.2 bin\DTcomment{Command Line Interface}.
.2 lib\DTcomment{Runtime Type Checking Library}.
.2 mutators\DTcomment{AST Node Transformers}.
.2 bus.ts\DTcomment{Event Bus}.
.2 context.ts\DTcomment{Mutation Context}.
.2 index.ts\DTcomment{API Exposure}.
.2 factory.ts\DTcomment{Common AST Node Transformations}.
.2 options.ts\DTcomment{Default Options}.
.2 scanner.ts\DTcomment{AST Scanner}.
.2 transform.ts\DTcomment{Application Core}.
.2 util.ts\DTcomment{Miscellaneous Utilities}.
}

\section{Components}
\label{sec:components}


In this section the implementation of the core of the project, as well as the application's components, will be described. The main focus will be on challenges that had to be overcome, and on the interconnections of the different parts of the program.

\subsection{Transformer}

The \emph{Transformer}, located in \texttt{src/transformer.ts}, is the core of the thesis project and exposes three methods, that may be utilized via the project's API:
\begin{itemize}
  \item \texttt{\textbf{getOptions:}} This function accepts an object as parameter, that aligns with the \emph{Options} interface, described later in this section. It then merges the passed object with the default settings, and returns the result. This ensures, that all required options are contained in the resulting object.
  \item \texttt{\textbf{transform:}} By calling this method, a transformation process is initiated. It is required to pass at least a list of entry file names. Optionally, an \emph{Options} object may be passed as well. Nothing is returned, but the compiled JavaScript files are written to disk, according to the TypeScript compiler options, if no errors occurred.
  \item \texttt{\textbf{transformReflection:}} The \texttt{transform} function loads the list of files from disk, which requires a file system to be present. On the contrary, this method accepts a list of file reflections, that must include the passed entry files, as well as all modules referenced, recursively. This enables the application, to act without a real file system. Also the target code is not persisted, but a list of file reflections, containing the compilation result, is returned.
\end{itemize}
Program~\ref{prog:transform} shows a, reduced to its essentials, version of the \texttt{transform} function.
\begin{program}
\caption{The \texttt{transform} function of the project's core, reduced to its essentials. The \texttt{ts} namespace from line~\ref{prog:transform:ts1} and~\ref{prog:transform:ts2} point to the TypeScript API.}
\label{prog:transform}
\begin{JsCode}
transform(entryFiles: string[], options?: Options} {
  const opts = getOptions(options);
  const program = ts.createProgram(entryFiles, opts.compilerOptions); /+\label{prog:transform:ts1}+/
  const scanner = new Scanner(program, opts);
  const files = program.getSourceFiles();
  const result = ts.transform(files, [transformer], opts.compilerOptions); /+\label{prog:transform:ts2}+/ /+\label{prog:transform:transformer}+/
  emit(result);
}
\end{JsCode}
\end{program}
%TODO: Add ref
It is not fully functional, but should give an idea of the program flow, also depicted in figure~REF!!!. On line~\ref{prog:transform:transformer}, a variable \texttt{transformer} is passed to a function from the TypeScript compiler API. This identifier references a function, that visits every node of the AST from all source files of the TypeScript program, which are passed to the mutators of \emph{ts-runtime}.

\subsection{Mutators}
% describe base mutator



%Based on the definition of cases, where type reflections and assertions need to be performed, described in section~\ref{sec:type-check-situations}, 

% Itemize all mutators

\subsection{Options}

\subsection{Transformer}

\subsection{Event Bus}

\subsection{Scanner}

\subsection{Factory}

\subsection{Utilities}

%\section{Transformation Results}
%\label{sec:transformation-results}
%
%\subsection{SourceFile}
%
%\subsection{Variables}
%
%\subsection{Type Assertions}
%
%\subsection{Functions}
%
%\subsection{Type Queries}
%
%\subsection{Enumerations}
%
%\subsection{Type Aliases}
%
%\subsection{Interfaces}
%
%\subsection{Classes}
%
%\subsection{Method Overloads}
%
%\subsection{Generics}
%
%\subsection{Externals}
%
%\subsection{Ambient Declarations}

\section{Usage}
\label{sec:usage}

\subsection{Programming Interface}
\label{sec:usage-api}

\subsection{Command Line Interface}
\label{sec:usage-cli}
